"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const multisetJaccard=require("multiset-jaccard"),jacc=require("jaccard");class Euclidean{calcDistance(e,t){if(e.length!==t.length)throw new Error("Points must have identical number of dimensions!");let n=0;for(let r=0,a=e.length;r<a;r++)n+=Math.pow(e[r]-t[r],2);return Math.sqrt(n)}calcDistanceSoft(e,t){if(e.length!==t.length)throw new Error("Points must have identical number of dimensions!");let n=0;for(let r=0,a=e.length;r<a;r++)e[r]>0&&(n+=Math.pow(e[r]-t[r],2));return Math.sqrt(n)}distance(e){return(1-e/100)*Math.sqrt(2)}maxDistance(){return Math.sqrt(2)}}class ChiSquare{calcDistance(e,t){if(e.length!==t.length)throw new Error("Points must have identical number of dimensions");let n=0;for(let r=0,a=e.length;r<a;r++)e[r]!==t[r]&&(n+=Math.pow(e[r]-t[r],2)/(e[r]+t[r]));return n}calcDistanceSoft(e,t){if(e.length!==t.length)throw new Error("Points must have identical number of dimensions!");let n=0;for(let r=0,a=e.length;r<a;r++)e[r]>0&&e[r]!==t[r]&&(n+=Math.pow(e[r]-t[r],2)/(e[r]+t[r]));return n}maxDistance(){return 2}}class Jaccard{calcMultisetDistance(e,t){return 1-multisetJaccard.index(e,t)}calcDistance(e,t){return 1-jacc.index(e,t)}}class S2JSD{calcDistance(e,t){if(e.length!==t.length)throw new Error("Points must have identical number of dimensions!");let n=0;for(let r=0,a=e.length;r<a;r++)e[r]!==t[r]&&(n+=Math.pow(e[r]-t[r],2)/(e[r]+t[r]));return Math.sqrt(.5*n)}calcDistanceSoft(e,t){if(e.length!==t.length)throw new Error("Points must have identical number of dimensions");let n=0;for(let r=0,a=e.length;r<a;r++)e[r]>0&&e[r]!==t[r]&&(n+=Math.pow(e[r]-t[r],2)/(e[r]+t[r]));return Math.sqrt(.5*n)}maxDistance(){return 1}}const euclidean=new Euclidean;exports.Euclidean=euclidean;const chiSquare=new ChiSquare;exports.ChiSquare=chiSquare;const s2jsd=new S2JSD;exports.S2JSD=s2jsd;const jaccard=new Jaccard;exports.Jaccard=jaccard;